{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction In the blockchain space, many people and many projects put the technology before the citizen, trying to retrofit privacy and data protection into a system that was not designed with those requirements from the beginning. Surprisingly, this also applies to many implementations and initiatives in the Self-Sovereign Identity (SSI) space, where many initiatives insist on registering and recording the identities of citizens in a globally shared infrastructure, even though it is not really required or desirable for many important use cases. Even though they claim that they use cryptographic techniques (from hashes to Zero-Knowledge Proofs) to achieve privacy, many claim so without a proper PIA (Privacy Impact Assessment) of the actual implementation in a concrete system. And most importantly, they assume that registering the identities of citizens is required without providing a proper justification, violating the principles of purpose limitation and data minimisation ( Articles 5.1.b and 5.1.c of GDPR ). To make things worst, due to the COVID19 pandemia there has been a proliferation of initiatives and projects advocating the use of Verifiable Credentials and blockchain technologies, but lacking the principle of \"citizen first, technology last\". Those initiatives tend to be the most publicised, creating a generalised distrust on blockchain for use cases where strong privacy and citizen protection is critical. However, many important use cases can leverage the power of Verifiable Credentials and the blockchain without compromising personal data. Relationship with the EU Digital COVID Credential The recent Guidelines from the eHealth Network , especially the document on interoperability of the Trust Framework (Interoperability of health certificates Trust framework) have made clear the requirements and characteristics that such solutions must comply with, striking the right balance between citizen and public health. Even though the documents assume centralised technology for implementation, they provide leeway in some areas where proper use of blockchain technology and Verifiable Credentials could add value, complementing and enhancing the solution delineated in the Guidelines while maintaining the principles of strong privacy and data protection, cross-border interoperability, inclusiveness and simplicity and user-friendliness. The Guidelines can be generalised to be used for the correct implementation of many different use cases in many industries (not limited to COVID certificates), ensuring that the same principles mentioned above are implemented. About PrivacyCred PrivacyCred is a generic digital credential system which is designed to be secure, privacy-preserving, scalable, performant and robust. It is designed specifically for some important use cases where physical, on-person verification of identity of holder is needed and where normal W3C Verifiable Credential flows are not fully suitable as they are normally designed currently.","title":"Introduction"},{"location":"#introduction","text":"In the blockchain space, many people and many projects put the technology before the citizen, trying to retrofit privacy and data protection into a system that was not designed with those requirements from the beginning. Surprisingly, this also applies to many implementations and initiatives in the Self-Sovereign Identity (SSI) space, where many initiatives insist on registering and recording the identities of citizens in a globally shared infrastructure, even though it is not really required or desirable for many important use cases. Even though they claim that they use cryptographic techniques (from hashes to Zero-Knowledge Proofs) to achieve privacy, many claim so without a proper PIA (Privacy Impact Assessment) of the actual implementation in a concrete system. And most importantly, they assume that registering the identities of citizens is required without providing a proper justification, violating the principles of purpose limitation and data minimisation ( Articles 5.1.b and 5.1.c of GDPR ). To make things worst, due to the COVID19 pandemia there has been a proliferation of initiatives and projects advocating the use of Verifiable Credentials and blockchain technologies, but lacking the principle of \"citizen first, technology last\". Those initiatives tend to be the most publicised, creating a generalised distrust on blockchain for use cases where strong privacy and citizen protection is critical. However, many important use cases can leverage the power of Verifiable Credentials and the blockchain without compromising personal data.","title":"Introduction"},{"location":"#relationship-with-the-eu-digital-covid-credential","text":"The recent Guidelines from the eHealth Network , especially the document on interoperability of the Trust Framework (Interoperability of health certificates Trust framework) have made clear the requirements and characteristics that such solutions must comply with, striking the right balance between citizen and public health. Even though the documents assume centralised technology for implementation, they provide leeway in some areas where proper use of blockchain technology and Verifiable Credentials could add value, complementing and enhancing the solution delineated in the Guidelines while maintaining the principles of strong privacy and data protection, cross-border interoperability, inclusiveness and simplicity and user-friendliness. The Guidelines can be generalised to be used for the correct implementation of many different use cases in many industries (not limited to COVID certificates), ensuring that the same principles mentioned above are implemented.","title":"Relationship with the EU Digital COVID Credential"},{"location":"#about-privacycred","text":"PrivacyCred is a generic digital credential system which is designed to be secure, privacy-preserving, scalable, performant and robust. It is designed specifically for some important use cases where physical, on-person verification of identity of holder is needed and where normal W3C Verifiable Credential flows are not fully suitable as they are normally designed currently.","title":"About PrivacyCred"},{"location":"architecture/ar-overview/","text":"Overview of the system This section provides an overview of the system. The description is focused especially on the privacy characterictics of the system, given that it is the most important property. The three zones for personal data To facilitate reasoning about tecnology and personal data, the system can be divided into three relevant zones. The three zones for personal data At the top we have the citizen's zone , represented in green. In the intermediate level we have the entities zone , with the businesses and organistions that manage or process personal data from the citizens, and represented in yellow. At the bottom we have the blockchain zone . It is red because the fundamental rule for any blockchain application is that personal data never has to be written to the blockchain, even if it is encrypted (encrypted personal data is considered personal data if it is exposed publicly for a sufficiently long period). We could start discussing about what can be considered personal data, and if a hash of personal data is considered personal data or not. But this is irrelevant here because in this system no personal data is ever written to the blockchain, including any type of hash from personal data. The information stored in the blockchain is the identities of the juridical persons involved, including the public key that will be used to verify the signatures from the entities issuing certificates. The blockchain stores the Trusted List of en that the entities issuing certificates Lo que se graba en el Blockchain (que en este caso es la Red T de los socios de Alastria), son las identidades de las personas jur\u00eddicas que intervienen, que incluye la clave p\u00fablica que las entidades emisoras de certificados usar\u00e1n para firmar digitalmente los certificados en formato Credencial Digital COVID EU. Porque el sistema utiliza el mismo formato de datos, pero lo mejora y simplifica gracias al uso de una red Blockchain. Es decir, en el Blockchain se almacena y gestiona la Lista de Entidades Confiables que son las \u00fanicas autorizadas a emitir certificados. The flow of a certificate The following figure describes the basic flow of a certificate: The flow of certificate The authorised issuer entity creates and digitally signs the certificate, and sends it to the citizen via several mechanisms. The personal data flows are marked in red. The relationship between the citizen and the issuer entity is subject to current regulation (e.g., GDPR) and the existence of the blockchain does not change anything. The diagram presents also the possibility that the entity stores some personal data in its own data base, always within the framework of the same personal data regulation. The critical feature is that there is not any write operation to the blockchain during the issuance process. The certificate is sent from the citizen to the verifier by means of a QR code which is implemented in such a way that there is no need for any intermediate server. Transmission is purely P2P in the safe citizen's zone without involvement of any entity, of course not even the issuer of the certificate. Replicating the privacy features of the physical world The privacy features of the system can be better understood by making an analogy with the real world: The citizen is holding a wallet and a set of cards inside. Comparison with a physical wallet This is represented in the figure above and the following properties hold: The citizen can use whatever wallet she wishes, because the wallet follows a set of standards. In the physical world, all wallets are interchangeable as far as they can hold standard-size cards. The citizen can use more than one wallet, either in parallel or sequentially. In the physical world, she can easily move the cards from one wallet to another, depending on the situation (e.g., she goes to the beach and moves a subset of the cards to a special wallet for a specific period of time). In order to obtain a wallet, the citizen does not need to register in any system or provide any personal data to any entity. In the analogy with the physical world, the citizen can go to a shop and pay for a wallet she likes in complete anonymity with respect to the wallet seller. There may be wallets for free (e.g., as gifts from entities), or if the customer so wishes, fancy wallets that the citizen has to pay. The above does not preclude the existence of wallets that require registration from citizens (and so requiring personal data). In the physical world, this may be analogous to obtaining a wallet because the citizen belongs to a club or is employed in a company, or as a gift because the citizen is the customer of a company. Once the citizen uses the wallet, the wallet does not send any personal information to the provider of the wallet. In the physical world, once the citizen has received the wallet, the seller of the wallet has no idea of what is the actual usage of the wallet by the citizen. However the digital wallet may communicate with the wallet provider to obtain patches or upgrades, especially security fixes. In the physical world this would be analogous to the citizen going to the shop for some repairs on her wallet. Obtaining the public keys for local verification in the mobile We now complete the flow of information in the system for the basic credential issuance and verification process. In order to be able to perform local verification of credentials in the mobile, we need the public keys of issuers. This is represented in the following figure, where the arrows are green because the information is public and in addition they are queries, never writes. There may be two main scenarios: one where the verifier is an individual citizen and the second when the verifier is an employee acting on behalf of a company that wants to verify certificates as part of its business process (e.g., a hotel on check-in of guests). We discuss here the first scenario, and the second will be discussed in the next section. Public keys and local verification In this scenario there are two citizens involved: the one holding the credential and the one acting as verifier. The mobile of the citizen acting as verifier can not access directly the blockchain and requires an intermediate server, operated by some entity. Typically, that entity operates both a \"traditional\" server and a blockchain node that it can access without restriction. From the point of view of data privacy, the intermediate server can never have access to the personal data of the citizen presenting the credential to the verifier. For the verifier, the amount of harm that an untrusted entity can make is very low, but in any case it is important that verifiers use a trusted server or even better a pool of trusted servers. The server receives HTTP GET requests from the verifier mobile for retrieving the public keys. Even though this is not done on each verification (the verifier mobile has a cache which is updated periodically), those requests could be used to try to track the citizen acting as verifier, using techniques like for example device fingerprinting . It is expected that several trusted entities like public administrations, civil organisations or highly-regulated businesses operate intermediate servers that offer publicly the single API which is required for trusted verification by citizens. The service is just a query, very simple and can use aggressive caching techniques so it can scale massively. Having a pool of public trusted operators of this service improves the resiliency of the verifier against malicious attacks. The citizen acting as verifier can configure the application to build the cache of public keys from queries to several servers, detecting wrong keys and avoiding censorship of some keys or just availability problems in the servers. Optional: verification in a server In the case when the verifier is an employee acting on behalf of an entity and especially for very small businessess, the scheme described above can also be used. It may also be possible that an industry association provides one or more servers providing the service to its member entities, probably together with the \"traditional\" services that they may already be receiving from the industry association. The system also supports making the verification in a given server. This feature may be useful for bigger entities and in some scenarios where they want to apply sophisticated business rules to the verification process, or when they require the storage in their databases of the credential data. This is represented in the following diagram. Verification in a server When making the validation in the server the verifier mobile has to send the certificate to the server, and this is represented by the new arrow in the diagram. The arrow is red because there is personal data involved. The entity receiving the personal data should comply with all applicable regulations. From the diagram it is easy to see that the existence of a blockchain network does not have any influence in how personal data should be handled by all actors involved.","title":"Overview"},{"location":"architecture/ar-overview/#overview-of-the-system","text":"This section provides an overview of the system. The description is focused especially on the privacy characterictics of the system, given that it is the most important property.","title":"Overview of the system"},{"location":"architecture/ar-overview/#the-three-zones-for-personal-data","text":"To facilitate reasoning about tecnology and personal data, the system can be divided into three relevant zones. The three zones for personal data At the top we have the citizen's zone , represented in green. In the intermediate level we have the entities zone , with the businesses and organistions that manage or process personal data from the citizens, and represented in yellow. At the bottom we have the blockchain zone . It is red because the fundamental rule for any blockchain application is that personal data never has to be written to the blockchain, even if it is encrypted (encrypted personal data is considered personal data if it is exposed publicly for a sufficiently long period). We could start discussing about what can be considered personal data, and if a hash of personal data is considered personal data or not. But this is irrelevant here because in this system no personal data is ever written to the blockchain, including any type of hash from personal data. The information stored in the blockchain is the identities of the juridical persons involved, including the public key that will be used to verify the signatures from the entities issuing certificates. The blockchain stores the Trusted List of en that the entities issuing certificates Lo que se graba en el Blockchain (que en este caso es la Red T de los socios de Alastria), son las identidades de las personas jur\u00eddicas que intervienen, que incluye la clave p\u00fablica que las entidades emisoras de certificados usar\u00e1n para firmar digitalmente los certificados en formato Credencial Digital COVID EU. Porque el sistema utiliza el mismo formato de datos, pero lo mejora y simplifica gracias al uso de una red Blockchain. Es decir, en el Blockchain se almacena y gestiona la Lista de Entidades Confiables que son las \u00fanicas autorizadas a emitir certificados.","title":"The three zones for personal data"},{"location":"architecture/ar-overview/#the-flow-of-a-certificate","text":"The following figure describes the basic flow of a certificate: The flow of certificate The authorised issuer entity creates and digitally signs the certificate, and sends it to the citizen via several mechanisms. The personal data flows are marked in red. The relationship between the citizen and the issuer entity is subject to current regulation (e.g., GDPR) and the existence of the blockchain does not change anything. The diagram presents also the possibility that the entity stores some personal data in its own data base, always within the framework of the same personal data regulation. The critical feature is that there is not any write operation to the blockchain during the issuance process. The certificate is sent from the citizen to the verifier by means of a QR code which is implemented in such a way that there is no need for any intermediate server. Transmission is purely P2P in the safe citizen's zone without involvement of any entity, of course not even the issuer of the certificate.","title":"The flow of a certificate"},{"location":"architecture/ar-overview/#replicating-the-privacy-features-of-the-physical-world","text":"The privacy features of the system can be better understood by making an analogy with the real world: The citizen is holding a wallet and a set of cards inside. Comparison with a physical wallet This is represented in the figure above and the following properties hold: The citizen can use whatever wallet she wishes, because the wallet follows a set of standards. In the physical world, all wallets are interchangeable as far as they can hold standard-size cards. The citizen can use more than one wallet, either in parallel or sequentially. In the physical world, she can easily move the cards from one wallet to another, depending on the situation (e.g., she goes to the beach and moves a subset of the cards to a special wallet for a specific period of time). In order to obtain a wallet, the citizen does not need to register in any system or provide any personal data to any entity. In the analogy with the physical world, the citizen can go to a shop and pay for a wallet she likes in complete anonymity with respect to the wallet seller. There may be wallets for free (e.g., as gifts from entities), or if the customer so wishes, fancy wallets that the citizen has to pay. The above does not preclude the existence of wallets that require registration from citizens (and so requiring personal data). In the physical world, this may be analogous to obtaining a wallet because the citizen belongs to a club or is employed in a company, or as a gift because the citizen is the customer of a company. Once the citizen uses the wallet, the wallet does not send any personal information to the provider of the wallet. In the physical world, once the citizen has received the wallet, the seller of the wallet has no idea of what is the actual usage of the wallet by the citizen. However the digital wallet may communicate with the wallet provider to obtain patches or upgrades, especially security fixes. In the physical world this would be analogous to the citizen going to the shop for some repairs on her wallet.","title":"Replicating the privacy features of the physical world"},{"location":"architecture/ar-overview/#obtaining-the-public-keys-for-local-verification-in-the-mobile","text":"We now complete the flow of information in the system for the basic credential issuance and verification process. In order to be able to perform local verification of credentials in the mobile, we need the public keys of issuers. This is represented in the following figure, where the arrows are green because the information is public and in addition they are queries, never writes. There may be two main scenarios: one where the verifier is an individual citizen and the second when the verifier is an employee acting on behalf of a company that wants to verify certificates as part of its business process (e.g., a hotel on check-in of guests). We discuss here the first scenario, and the second will be discussed in the next section. Public keys and local verification In this scenario there are two citizens involved: the one holding the credential and the one acting as verifier. The mobile of the citizen acting as verifier can not access directly the blockchain and requires an intermediate server, operated by some entity. Typically, that entity operates both a \"traditional\" server and a blockchain node that it can access without restriction. From the point of view of data privacy, the intermediate server can never have access to the personal data of the citizen presenting the credential to the verifier. For the verifier, the amount of harm that an untrusted entity can make is very low, but in any case it is important that verifiers use a trusted server or even better a pool of trusted servers. The server receives HTTP GET requests from the verifier mobile for retrieving the public keys. Even though this is not done on each verification (the verifier mobile has a cache which is updated periodically), those requests could be used to try to track the citizen acting as verifier, using techniques like for example device fingerprinting . It is expected that several trusted entities like public administrations, civil organisations or highly-regulated businesses operate intermediate servers that offer publicly the single API which is required for trusted verification by citizens. The service is just a query, very simple and can use aggressive caching techniques so it can scale massively. Having a pool of public trusted operators of this service improves the resiliency of the verifier against malicious attacks. The citizen acting as verifier can configure the application to build the cache of public keys from queries to several servers, detecting wrong keys and avoiding censorship of some keys or just availability problems in the servers.","title":"Obtaining the public keys for local verification in the mobile"},{"location":"architecture/ar-overview/#optional-verification-in-a-server","text":"In the case when the verifier is an employee acting on behalf of an entity and especially for very small businessess, the scheme described above can also be used. It may also be possible that an industry association provides one or more servers providing the service to its member entities, probably together with the \"traditional\" services that they may already be receiving from the industry association. The system also supports making the verification in a given server. This feature may be useful for bigger entities and in some scenarios where they want to apply sophisticated business rules to the verification process, or when they require the storage in their databases of the credential data. This is represented in the following diagram. Verification in a server When making the validation in the server the verifier mobile has to send the certificate to the server, and this is represented by the new arrow in the diagram. The arrow is red because there is personal data involved. The entity receiving the personal data should comply with all applicable regulations. From the diagram it is easy to see that the existence of a blockchain network does not have any influence in how personal data should be handled by all actors involved.","title":"Optional: verification in a server"},{"location":"credentials/eu-covid/","text":"EU Digital COVID Credentials The system supports the EU Digital COVID Credentials both for storing and verifying them with the wallet and verifier applications. The system supports generating credentials using exactly the same format as the EU Digital COVID Credential , but in our case the public keys are stored in the blockchain, together with the identities of all entities authorised to issue credentials. The format and interoperability guidelines are defined in the related documentation from the EU.","title":"EU COVID"},{"location":"credentials/eu-covid/#eu-digital-covid-credentials","text":"The system supports the EU Digital COVID Credentials both for storing and verifying them with the wallet and verifier applications. The system supports generating credentials using exactly the same format as the EU Digital COVID Credential , but in our case the public keys are stored in the blockchain, together with the identities of all entities authorised to issue credentials. The format and interoperability guidelines are defined in the related documentation from the EU.","title":"EU Digital COVID Credentials"},{"location":"credentials/w3c/","text":"W3C Verifiable Credentials Data Model The credential uses the standard W3C Verifiable Credentials Data Model for its representation, with some extensions to facilitate interoperability across blockchains. The specific credential data is encoded in the credentialSubject field of the VC. The following figure represents the VC structure without the specific credential data. The figure above represents the VC where some fields have been marked: The iss field (issuer in VC terminology), uses the DID method elsi , specific for juridical persons and explained in a section below. There is an extension to specify the blockchain network (or networks) where the VC can be verified. More precisely, the issuedAt field of credentialSubject specifies the networks where the identity for the juridical person that issued the credential can be verified. A juridical person can have its elsi DID registered in one or more networks, and the same credential can be verified using any of those networks. The trust on the credential depends on the trust on the registration procedure of the identity of the signer. The Verifier entity can choose to verify the credential in whatever network is trusted to the Verifier. This mechanism provides a lot of flexibility in interoperability schemes across networks. More details are described in the section on interoperability. Example of Verifiable Credential { \"exp\" : 1614770844 , \"iat\" : 1614252444 , \"iss\" : \"did:elsi:VATES-X12345678X\" , \"sub\" : \"46106508H\" , \"uuid\" : \"829588b3162249d28f3eae5e84349777\" , \"vc\" : { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://alastria.github.io/identity/credentials/v1\" , \"https://privacycred.org/.well-known/privacycred/v1\" ], \"type\" : [ \"VerifiableCredential\" , \"AlastriaVerifiableCredential\" , \"PrivacyCredential\" ], \"credentialSchema\" : { \"id\" : \"PrivacyCredential\" , \"type\" : \"JsonSchemaValidator2018\" }, \"credentialSubject\" : { \"privacyCredential\" : { \"citizen\" : { \"dob\" : \"27-04-1982\" , \"idnumber\" : \"46106508H\" , \"name\" : \"COSTA/ALBERTO\" , \"type\" : \"atRisk\" }, \"comments\" : \"These are some comments\" }, \"issuedAt\" : [ \"redt.alastria\" ], \"levelOfAssurance\" : 2 } } } Verification of the credentials In general, verifying a credential received as a JWT involves the following: Deserialize the JWT without verifying it (we do not yet have the public key). Get the kid property from the header (the JOSE header of the JWT). The kid has the format did#id where did is the DID of the issuer and id is the identifier of the key in the DIDDocument associated to the DID. Perform resolution of the DID of the issuer with the Universal Resolver API. Get the public key specified inside the DIDDocument. Verify the JWT using the public key associated to the DID. Verify that the DID in the iss field of the JWT payload is the same as the one that signed the JWT. The system includes two APIs to help client applications with the verification of credentials received from other actors in the ecosystem. The choice of API depends on the trust level of the client application on the server implementing the APIs. Using the Universal Resolver API In the first option the client obtains the public key of the Issuer via DID resolution. Then the client performs the cryptographic verification using the public key, without reliance on any other party. The API for DID resolution is described below: GET /api/did/v1/identifiers/{string:DID} Resolves a DID and returns the DID Document (JSON format), if it exists. It supports four DID methods: ebsi , elsi , ala , peer . Only PEER and ELSI are directly implemented by this API. The others are delegated to be resolved by their respective implementations. For example, for EBSI we call the corresponding Universal Resolver API, currently in testing and available at https://api.ebsi.xyz/did/v1/identifiers/ Request parameters Name Type Description Default DID string The DID to resolve into a DID Document None Reply Name Type Description payload json The DID document associated to the input DID Status codes Code Meaning 200 no error 404 error resolving the DID Example request : GET /api/did/v1/identifiers/did:elsi:VATES-B60645900 HTTP / 1.1 Host : example.com Accept : application/json Example response : { \"payload\" : { \"@context\" : [ \"https://www.w3.org/ns/did/v1\" , \"https://w3id.org/security/v1\" ], \"id\" : \"did:elsi:VATES-B60645900\" , \"verificationMethod\" : [ { \"id\" : \"did:elsi:VATES-B60645900#key-verification\" , \"type\" : \"JwsVerificationKey2020\" , \"controller\" : \"did:elsi:VATES-B60645900\" , \"publicKeyJwk\" : { \"kid\" : \"key-verification\" , \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"x\" : \"3K4iNuzPkcrHlEbhHE8vYXlF6K5xGZ2rdOrn3cQ-LnQ\" , \"y\" : \"9Z_l_hQLkq6aLuZz8gheq7R_o5ZUHUlxZ3IBGHsdzaA\" } } ], \"service\" : [ { \"id\" : \"did:elsi:VATES-B60645900#info\" , \"type\" : \"EntityCommercialInfo\" , \"serviceEndpoint\" : \"www.in2.es\" , \"name\" : \"IN2 Innovating 2gether\" }, { \"id\" : \"did:elsi:VATES-B60645900#sms\" , \"type\" : \"SecureMessagingService\" , \"serviceEndpoint\" : \"https://privatecred.hesusruiz.org/api\" } ], \"anchors\" : [ { \"id\" : \"redt.alastria\" , \"resolution\" : \"UniversalResolver\" , \"domain\" : \"in2.ala\" , \"ethereumAddress\" : \"0x8CDA8113567e633805e48c87747257E9FFAAdDF5\" } ], \"created\" : \"2021-02-08T06:53:08Z\" , \"updated\" : \"2021-02-08T06:53:08Z\" } } Delegating verification to a trusted server In the second option the client delegates to a trusted server the verification of the credential, simplifying the code and complexity of secure cryptographic operatios to the server. This option maybe used when the client trusts the server as it happens when they are operated by the same entity. It can be also used when the server is operated by a public administration and the citizen trusts on it. This is the easiest one to use, but requires a very high level of trust. The API is described below: POST /api/verifiable-credential/v1/verifiable-credential-validations Receives a JWT in the JWS Compact Serialization format ( RFC 7519 ) as the body of the POST request and the server verifies the credential and credential signature using internally the Universal Resolver API for resolving the DID of the Issuer and checking its digital signature. Request body Type Description Default json The credential in JWT format None Reply Name Type Description payload json The JSON object with the verified claims in the JWT Status codes Code Meaning 200 no error 404 error resolving the DID","title":"W3C VC"},{"location":"credentials/w3c/#w3c-verifiable-credentials","text":"","title":"W3C Verifiable Credentials"},{"location":"credentials/w3c/#data-model","text":"The credential uses the standard W3C Verifiable Credentials Data Model for its representation, with some extensions to facilitate interoperability across blockchains. The specific credential data is encoded in the credentialSubject field of the VC. The following figure represents the VC structure without the specific credential data. The figure above represents the VC where some fields have been marked: The iss field (issuer in VC terminology), uses the DID method elsi , specific for juridical persons and explained in a section below. There is an extension to specify the blockchain network (or networks) where the VC can be verified. More precisely, the issuedAt field of credentialSubject specifies the networks where the identity for the juridical person that issued the credential can be verified. A juridical person can have its elsi DID registered in one or more networks, and the same credential can be verified using any of those networks. The trust on the credential depends on the trust on the registration procedure of the identity of the signer. The Verifier entity can choose to verify the credential in whatever network is trusted to the Verifier. This mechanism provides a lot of flexibility in interoperability schemes across networks. More details are described in the section on interoperability.","title":"Data Model"},{"location":"credentials/w3c/#example-of-verifiable-credential","text":"{ \"exp\" : 1614770844 , \"iat\" : 1614252444 , \"iss\" : \"did:elsi:VATES-X12345678X\" , \"sub\" : \"46106508H\" , \"uuid\" : \"829588b3162249d28f3eae5e84349777\" , \"vc\" : { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://alastria.github.io/identity/credentials/v1\" , \"https://privacycred.org/.well-known/privacycred/v1\" ], \"type\" : [ \"VerifiableCredential\" , \"AlastriaVerifiableCredential\" , \"PrivacyCredential\" ], \"credentialSchema\" : { \"id\" : \"PrivacyCredential\" , \"type\" : \"JsonSchemaValidator2018\" }, \"credentialSubject\" : { \"privacyCredential\" : { \"citizen\" : { \"dob\" : \"27-04-1982\" , \"idnumber\" : \"46106508H\" , \"name\" : \"COSTA/ALBERTO\" , \"type\" : \"atRisk\" }, \"comments\" : \"These are some comments\" }, \"issuedAt\" : [ \"redt.alastria\" ], \"levelOfAssurance\" : 2 } } }","title":"Example of Verifiable Credential"},{"location":"credentials/w3c/#verification-of-the-credentials","text":"In general, verifying a credential received as a JWT involves the following: Deserialize the JWT without verifying it (we do not yet have the public key). Get the kid property from the header (the JOSE header of the JWT). The kid has the format did#id where did is the DID of the issuer and id is the identifier of the key in the DIDDocument associated to the DID. Perform resolution of the DID of the issuer with the Universal Resolver API. Get the public key specified inside the DIDDocument. Verify the JWT using the public key associated to the DID. Verify that the DID in the iss field of the JWT payload is the same as the one that signed the JWT. The system includes two APIs to help client applications with the verification of credentials received from other actors in the ecosystem. The choice of API depends on the trust level of the client application on the server implementing the APIs.","title":"Verification of the credentials"},{"location":"credentials/w3c/#using-the-universal-resolver-api","text":"In the first option the client obtains the public key of the Issuer via DID resolution. Then the client performs the cryptographic verification using the public key, without reliance on any other party. The API for DID resolution is described below: GET /api/did/v1/identifiers/{string:DID} Resolves a DID and returns the DID Document (JSON format), if it exists. It supports four DID methods: ebsi , elsi , ala , peer . Only PEER and ELSI are directly implemented by this API. The others are delegated to be resolved by their respective implementations. For example, for EBSI we call the corresponding Universal Resolver API, currently in testing and available at https://api.ebsi.xyz/did/v1/identifiers/ Request parameters Name Type Description Default DID string The DID to resolve into a DID Document None Reply Name Type Description payload json The DID document associated to the input DID Status codes Code Meaning 200 no error 404 error resolving the DID Example request : GET /api/did/v1/identifiers/did:elsi:VATES-B60645900 HTTP / 1.1 Host : example.com Accept : application/json Example response : { \"payload\" : { \"@context\" : [ \"https://www.w3.org/ns/did/v1\" , \"https://w3id.org/security/v1\" ], \"id\" : \"did:elsi:VATES-B60645900\" , \"verificationMethod\" : [ { \"id\" : \"did:elsi:VATES-B60645900#key-verification\" , \"type\" : \"JwsVerificationKey2020\" , \"controller\" : \"did:elsi:VATES-B60645900\" , \"publicKeyJwk\" : { \"kid\" : \"key-verification\" , \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"x\" : \"3K4iNuzPkcrHlEbhHE8vYXlF6K5xGZ2rdOrn3cQ-LnQ\" , \"y\" : \"9Z_l_hQLkq6aLuZz8gheq7R_o5ZUHUlxZ3IBGHsdzaA\" } } ], \"service\" : [ { \"id\" : \"did:elsi:VATES-B60645900#info\" , \"type\" : \"EntityCommercialInfo\" , \"serviceEndpoint\" : \"www.in2.es\" , \"name\" : \"IN2 Innovating 2gether\" }, { \"id\" : \"did:elsi:VATES-B60645900#sms\" , \"type\" : \"SecureMessagingService\" , \"serviceEndpoint\" : \"https://privatecred.hesusruiz.org/api\" } ], \"anchors\" : [ { \"id\" : \"redt.alastria\" , \"resolution\" : \"UniversalResolver\" , \"domain\" : \"in2.ala\" , \"ethereumAddress\" : \"0x8CDA8113567e633805e48c87747257E9FFAAdDF5\" } ], \"created\" : \"2021-02-08T06:53:08Z\" , \"updated\" : \"2021-02-08T06:53:08Z\" } }","title":"Using the Universal Resolver API"},{"location":"credentials/w3c/#delegating-verification-to-a-trusted-server","text":"In the second option the client delegates to a trusted server the verification of the credential, simplifying the code and complexity of secure cryptographic operatios to the server. This option maybe used when the client trusts the server as it happens when they are operated by the same entity. It can be also used when the server is operated by a public administration and the citizen trusts on it. This is the easiest one to use, but requires a very high level of trust. The API is described below: POST /api/verifiable-credential/v1/verifiable-credential-validations Receives a JWT in the JWS Compact Serialization format ( RFC 7519 ) as the body of the POST request and the server verifies the credential and credential signature using internally the Universal Resolver API for resolving the DID of the Issuer and checking its digital signature. Request body Type Description Default json The credential in JWT format None Reply Name Type Description payload json The JSON object with the verified claims in the JWT Status codes Code Meaning 200 no error 404 error resolving the DID","title":"Delegating verification to a trusted server"},{"location":"didmethods/elsi/","text":"ELSI: DID Method for organisations The system supports several DID Methods, using the Universal Resolver to resolve each DID into a corresponding DID Document. However, the main DID method used for organisations and currently implemented in Alastria Red-T is ELSI , where the identities of juridical persons are anchored into a Public-Permissioned blockchain. The name ELSI stands for E TSI L egal person S emantics I dentifier, because it is based on the Legal person semantic identifier defined in the European Norm ETSI EN 319 412-1 , related to digital signatures, peer entity authentication, data authentication as well as data confidentiality. The basic idea is to generate the DID deterministically from an existing and widely accepted identifier, which is already required by any organisation in the real world in order to perform any relevant activity. The rational for ELSI is the following: The DID for a juridical person is essentially different to the DID for a natural person. Identities of juridical persons are public, together with information associated to the identity. This is not optional, and before an organisation starts performing any relevant operation in the real world, it has to be registered in some official register, where the identity and associated information is publicly acessible. However, real-world identities of natural persons and associated PII are subject to very strict privacy regulations (GDPR). Identities are not public, and special care should be taken to keep everything related to the identity private. This suggests the need for totally different mechanisms to generate and manage the DIDs of those radically different types of entities. Clean separation of the mechanisms allows for easier implementation of each set of requirements, without polluting the code with logic to handle both cases, which is prone to error. Of course, there is nothing preventing reuse of common logic across both implementations, but only when it makes sense and maintaining the clean separation principle. In addition, this separation reflects current practice in managing identities of organisations and natural persons, so it is easier to leverage existing know-how. Most organisations can already be identified by the VAT or LEI (or both). For example, businesses have to be registered in the Business Registrar of the country of incorporation, including the compulsory Tax Identification Number or VAT. Even organisations which do not require a VAT to be incorporated are required to have a LEI (Legal Entity Identifier). Using the VAT and LEI can identify an enormous amount of organisations: businesses, non profits, universities, research centers, public administrations, etc. In exceptional cases where VAT or LEI can not be used, ELSI uses the extensibility mechanism in ETSI EN 319 412-1 to include any existing type of compulsory registration, whether international or just national. These requirements have nothing to do with whether we use centralised technology or blockchains. It is an essential characterictic in any developed economy like the EU. This means that the creation of the DID is completely decentralised from the point of view of the blockchain networks, because the entities willing to participate already possess everything which is needed in order to create the DID. We do not need to put in place any other entity or system to create the DID. The ETSI norm on which ELSI is based specifies several possible identifiers that can be used to build the DID. The two most common and the ones used in ELSI are the VAT (Tax Identifier) and the LEI ( Legal Entity Identifier ). Using both VAT and LEI in creating the DID covers every juridical person that can participate in a blockchain network, not only in the EU but in most of the world. In any case, the system is extensible and it is fairly easy to incorporate new legal identifiers if the need arises in the future. ELSI DID syntax The ELSI DID Method refers only to legal persons, so we are using the id-etsi-qcs-SemanticsId-Legal definition described in Section 5.1 of ETSI EN 319 412-1. Creating a DID is extremely simple and fully decentralized (does not require participation of any central authority), assuming that the legal person already exists. Its definition using ABNF syntax is: did = \"did:elsi:\" id - etsi - qcs - SemanticsId - Legal Which is the concatenation of the prefix did:elsi: with the legal person identifier defined in ETSI EN 319 412-1. For the full syntax, please refer to the standards document, but for the two most common basic identifiers (VAT and LEI) the identifier is composed of: 3 character legal person identity type reference, like VAT for identification based on a national value added tax identification number or LEI for the Legal Entity Identifier . 2 character ISO 3166 [2] country code; hyphen-minus \"-\" (0x2D (ASCII), U+002D (UTF-8)); and identifier (according to country and identity type reference). Some examples of DIDs are the following: Name DID AgID (www.agid.gov.it) did:elsi:VATIT-97735020584 Hashnet d.o.o. (hashnet.tech) did:elsi:VATSI-18035094 Alastria (alastria.io) did:elsi:VATES-G87936159 Enel Spa (www.enel.com) did:elsi:VATIT-15844561009 Endesa S.A. (www.endesa.com) did:elsi:VATES-A81948077 Inter-American Development Bank (www.iadb.org) did:elsi:LEIXG-VKU1UKDS9E7LYLMACP54 ELSI DID Document An example DID Document is the following: { \"payload\" : { \"@context\" : [ \"https://www.w3.org/ns/did/v1\" , \"https://w3id.org/security/v1\" ], \"id\" : \"did:elsi:VATES-B60645900\" , \"verificationMethod\" : [ { \"id\" : \"did:elsi:VATES-B60645900#key-verification\" , \"type\" : \"JwsVerificationKey2020\" , \"controller\" : \"did:elsi:VATES-B60645900\" , \"publicKeyJwk\" : { \"kid\" : \"key-verification\" , \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"x\" : \"3K4iNuzPkcrHlEbhHE8vYXlF6K5xGZ2rdOrn3cQ-LnQ\" , \"y\" : \"9Z_l_hQLkq6aLuZz8gheq7R_o5ZUHUlxZ3IBGHsdzaA\" } } ], \"service\" : [ { \"id\" : \"did:elsi:VATES-B60645900#info\" , \"type\" : \"EntityCommercialInfo\" , \"serviceEndpoint\" : \"www.in2.es\" , \"name\" : \"IN2 Innovating 2gether\" }, { \"id\" : \"did:elsi:VATES-B60645900#sms\" , \"type\" : \"SecureMessagingService\" , \"serviceEndpoint\" : \"https://privatecred.hesusruiz.org/api\" } ], \"anchors\" : [ { \"id\" : \"redt.alastria\" , \"resolution\" : \"UniversalResolver\" , \"domain\" : \"in2.ala\" , \"ethereumAddress\" : \"0x8CDA8113567e633805e48c87747257E9FFAAdDF5\" } ], \"created\" : \"2021-02-08T06:53:08Z\" , \"updated\" : \"2021-02-08T06:53:08Z\" } }","title":"ELSI"},{"location":"didmethods/elsi/#elsi-did-method-for-organisations","text":"The system supports several DID Methods, using the Universal Resolver to resolve each DID into a corresponding DID Document. However, the main DID method used for organisations and currently implemented in Alastria Red-T is ELSI , where the identities of juridical persons are anchored into a Public-Permissioned blockchain. The name ELSI stands for E TSI L egal person S emantics I dentifier, because it is based on the Legal person semantic identifier defined in the European Norm ETSI EN 319 412-1 , related to digital signatures, peer entity authentication, data authentication as well as data confidentiality. The basic idea is to generate the DID deterministically from an existing and widely accepted identifier, which is already required by any organisation in the real world in order to perform any relevant activity. The rational for ELSI is the following: The DID for a juridical person is essentially different to the DID for a natural person. Identities of juridical persons are public, together with information associated to the identity. This is not optional, and before an organisation starts performing any relevant operation in the real world, it has to be registered in some official register, where the identity and associated information is publicly acessible. However, real-world identities of natural persons and associated PII are subject to very strict privacy regulations (GDPR). Identities are not public, and special care should be taken to keep everything related to the identity private. This suggests the need for totally different mechanisms to generate and manage the DIDs of those radically different types of entities. Clean separation of the mechanisms allows for easier implementation of each set of requirements, without polluting the code with logic to handle both cases, which is prone to error. Of course, there is nothing preventing reuse of common logic across both implementations, but only when it makes sense and maintaining the clean separation principle. In addition, this separation reflects current practice in managing identities of organisations and natural persons, so it is easier to leverage existing know-how. Most organisations can already be identified by the VAT or LEI (or both). For example, businesses have to be registered in the Business Registrar of the country of incorporation, including the compulsory Tax Identification Number or VAT. Even organisations which do not require a VAT to be incorporated are required to have a LEI (Legal Entity Identifier). Using the VAT and LEI can identify an enormous amount of organisations: businesses, non profits, universities, research centers, public administrations, etc. In exceptional cases where VAT or LEI can not be used, ELSI uses the extensibility mechanism in ETSI EN 319 412-1 to include any existing type of compulsory registration, whether international or just national. These requirements have nothing to do with whether we use centralised technology or blockchains. It is an essential characterictic in any developed economy like the EU. This means that the creation of the DID is completely decentralised from the point of view of the blockchain networks, because the entities willing to participate already possess everything which is needed in order to create the DID. We do not need to put in place any other entity or system to create the DID. The ETSI norm on which ELSI is based specifies several possible identifiers that can be used to build the DID. The two most common and the ones used in ELSI are the VAT (Tax Identifier) and the LEI ( Legal Entity Identifier ). Using both VAT and LEI in creating the DID covers every juridical person that can participate in a blockchain network, not only in the EU but in most of the world. In any case, the system is extensible and it is fairly easy to incorporate new legal identifiers if the need arises in the future.","title":"ELSI: DID Method for organisations"},{"location":"didmethods/elsi/#elsi-did-syntax","text":"The ELSI DID Method refers only to legal persons, so we are using the id-etsi-qcs-SemanticsId-Legal definition described in Section 5.1 of ETSI EN 319 412-1. Creating a DID is extremely simple and fully decentralized (does not require participation of any central authority), assuming that the legal person already exists. Its definition using ABNF syntax is: did = \"did:elsi:\" id - etsi - qcs - SemanticsId - Legal Which is the concatenation of the prefix did:elsi: with the legal person identifier defined in ETSI EN 319 412-1. For the full syntax, please refer to the standards document, but for the two most common basic identifiers (VAT and LEI) the identifier is composed of: 3 character legal person identity type reference, like VAT for identification based on a national value added tax identification number or LEI for the Legal Entity Identifier . 2 character ISO 3166 [2] country code; hyphen-minus \"-\" (0x2D (ASCII), U+002D (UTF-8)); and identifier (according to country and identity type reference). Some examples of DIDs are the following: Name DID AgID (www.agid.gov.it) did:elsi:VATIT-97735020584 Hashnet d.o.o. (hashnet.tech) did:elsi:VATSI-18035094 Alastria (alastria.io) did:elsi:VATES-G87936159 Enel Spa (www.enel.com) did:elsi:VATIT-15844561009 Endesa S.A. (www.endesa.com) did:elsi:VATES-A81948077 Inter-American Development Bank (www.iadb.org) did:elsi:LEIXG-VKU1UKDS9E7LYLMACP54","title":"ELSI DID syntax"},{"location":"didmethods/elsi/#elsi-did-document","text":"An example DID Document is the following: { \"payload\" : { \"@context\" : [ \"https://www.w3.org/ns/did/v1\" , \"https://w3id.org/security/v1\" ], \"id\" : \"did:elsi:VATES-B60645900\" , \"verificationMethod\" : [ { \"id\" : \"did:elsi:VATES-B60645900#key-verification\" , \"type\" : \"JwsVerificationKey2020\" , \"controller\" : \"did:elsi:VATES-B60645900\" , \"publicKeyJwk\" : { \"kid\" : \"key-verification\" , \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"x\" : \"3K4iNuzPkcrHlEbhHE8vYXlF6K5xGZ2rdOrn3cQ-LnQ\" , \"y\" : \"9Z_l_hQLkq6aLuZz8gheq7R_o5ZUHUlxZ3IBGHsdzaA\" } } ], \"service\" : [ { \"id\" : \"did:elsi:VATES-B60645900#info\" , \"type\" : \"EntityCommercialInfo\" , \"serviceEndpoint\" : \"www.in2.es\" , \"name\" : \"IN2 Innovating 2gether\" }, { \"id\" : \"did:elsi:VATES-B60645900#sms\" , \"type\" : \"SecureMessagingService\" , \"serviceEndpoint\" : \"https://privatecred.hesusruiz.org/api\" } ], \"anchors\" : [ { \"id\" : \"redt.alastria\" , \"resolution\" : \"UniversalResolver\" , \"domain\" : \"in2.ala\" , \"ethereumAddress\" : \"0x8CDA8113567e633805e48c87747257E9FFAAdDF5\" } ], \"created\" : \"2021-02-08T06:53:08Z\" , \"updated\" : \"2021-02-08T06:53:08Z\" } }","title":"ELSI DID Document"},{"location":"trustframework/smart-contracts/","text":"Smart Contracts The Trust Framework is implemented by the Smart Contracts described below. The main registry ENSRegistry.sol Implements the main registry and is the first contract that should be deployed. ENS.sol Defines the interfaces and is included by ENSRegistry and other contracts. The resolver contracts These contracts implement resolution of different types of information that can be registered in the blockchain. PublicResolver.sol This is the main contract and the only one that must be compiled, because all others are included. ResolverBase.sol A utility contract used by all other contracts specialised in resolving different types of information. Inside the ''profiles'' directory we can find the specialised contracts, all of them are included by the PublicResolver.sol contract. AlaDIDPublicEntityResolver.sol Registers and resolves the identities of juridical persons (businesses, institutions, etc.). It keeps the DID and information required to build the associated DID Document. This contract registers and resolves the first public key associated to the DID. Additional public keys are registed using the AlaDIDPubkeyResolver contract. AlaDIDPubkeyResolver.sol Registers and resolves the public keys associated to the DID. In reality, it is used only if the DID has more than one public key. In the simple case where the DID has only one public key, it is registered and resolved directly by the AlaDIDPublicEntityResolver contract. AlaPublicCredentialResolver.sol Registers and resolves metadata about public credentials associated to the DID. In the case of juridical persons, they may want to register publicly available credentials (e.g. self-declarations). In general, the bulk of the credential data should be stored off-chain, but this contract allows registering critical credential metadata, including a tamper-resistant pointer to the actual location of the credential details. AlaTSPResolver.sol Registers and resolves special entities. It is a specialisation of AlaDIDPublicEntityResolver in the sense that it is intended for registration of the Trust Service Providers (TSPs), implementing the EU TSP List of Lists on the blockchian. It contains the associated X509 certificates for each TSP, making it very efficient to verify digital signatures existing off-chain. NameResolver.sol It performs reverse resolution, from domain name to blockchain address. Each entity in the Trust Framework has a domain name assigned at the moment of registration, much in the same way as it happens with standard domain names. This contract provides a secure way to determine from the domain name the blockchain address associated to it and then retrieve all additional information. ContentHashResolver.sol Registers and resolves Content-addressable Identifiers. It provides the ability for a DID to register pointers to additional information that they want to make available to the public. TextResolver.sol A general registration and resolution of any text that the DID wants to store associated to its DID. The content is free-format and can be used for almost any purpose that the DID wishes. However, being free-format means that the actual format and semantics may not be understood by everybody. Deployment of the Smart Contracts Compilation Only two contracts have to be compiled: ENSRegistry.sol and PublicResolver.sol . All the others are included by these two. Deployment The deployment has to be performed in strict order: first ENSRegistry.sol and then PublicResolver.sol . The constructor of PublicResolver.sol requires the deployed address of ENSRegistry.sol , so it can invoke its functions when registering/resolving information.","title":"Smart Contracts"},{"location":"trustframework/smart-contracts/#smart-contracts","text":"The Trust Framework is implemented by the Smart Contracts described below.","title":"Smart Contracts"},{"location":"trustframework/smart-contracts/#the-main-registry","text":"ENSRegistry.sol Implements the main registry and is the first contract that should be deployed. ENS.sol Defines the interfaces and is included by ENSRegistry and other contracts.","title":"The main registry"},{"location":"trustframework/smart-contracts/#the-resolver-contracts","text":"These contracts implement resolution of different types of information that can be registered in the blockchain. PublicResolver.sol This is the main contract and the only one that must be compiled, because all others are included. ResolverBase.sol A utility contract used by all other contracts specialised in resolving different types of information. Inside the ''profiles'' directory we can find the specialised contracts, all of them are included by the PublicResolver.sol contract. AlaDIDPublicEntityResolver.sol Registers and resolves the identities of juridical persons (businesses, institutions, etc.). It keeps the DID and information required to build the associated DID Document. This contract registers and resolves the first public key associated to the DID. Additional public keys are registed using the AlaDIDPubkeyResolver contract. AlaDIDPubkeyResolver.sol Registers and resolves the public keys associated to the DID. In reality, it is used only if the DID has more than one public key. In the simple case where the DID has only one public key, it is registered and resolved directly by the AlaDIDPublicEntityResolver contract. AlaPublicCredentialResolver.sol Registers and resolves metadata about public credentials associated to the DID. In the case of juridical persons, they may want to register publicly available credentials (e.g. self-declarations). In general, the bulk of the credential data should be stored off-chain, but this contract allows registering critical credential metadata, including a tamper-resistant pointer to the actual location of the credential details. AlaTSPResolver.sol Registers and resolves special entities. It is a specialisation of AlaDIDPublicEntityResolver in the sense that it is intended for registration of the Trust Service Providers (TSPs), implementing the EU TSP List of Lists on the blockchian. It contains the associated X509 certificates for each TSP, making it very efficient to verify digital signatures existing off-chain. NameResolver.sol It performs reverse resolution, from domain name to blockchain address. Each entity in the Trust Framework has a domain name assigned at the moment of registration, much in the same way as it happens with standard domain names. This contract provides a secure way to determine from the domain name the blockchain address associated to it and then retrieve all additional information. ContentHashResolver.sol Registers and resolves Content-addressable Identifiers. It provides the ability for a DID to register pointers to additional information that they want to make available to the public. TextResolver.sol A general registration and resolution of any text that the DID wants to store associated to its DID. The content is free-format and can be used for almost any purpose that the DID wishes. However, being free-format means that the actual format and semantics may not be understood by everybody.","title":"The resolver contracts"},{"location":"trustframework/smart-contracts/#deployment-of-the-smart-contracts","text":"","title":"Deployment of the Smart Contracts"},{"location":"trustframework/smart-contracts/#compilation","text":"Only two contracts have to be compiled: ENSRegistry.sol and PublicResolver.sol . All the others are included by these two.","title":"Compilation"},{"location":"trustframework/smart-contracts/#deployment","text":"The deployment has to be performed in strict order: first ENSRegistry.sol and then PublicResolver.sol . The constructor of PublicResolver.sol requires the deployed address of ENSRegistry.sol , so it can invoke its functions when registering/resolving information.","title":"Deployment"},{"location":"trustframework/tf-overview/","text":"Trust Framework Introduction The trust framework is basically composed of two things: A list of the identities of trusted organisations stored in the blockchain, together with associated information for each entity. A process to add, modify and delete the trusted entities. The trust framework is designed to be largely decentralised and represents the trust relationships in the real world. The identities of the juridical persons involved in the ecosystem are registered in a common directory implemented in the blockchain following a hierarchical scheme very similar to the DNS (Domain Name Service) schema in the Internet. Once an entity is registered in the system, it is completely autonomous for adding other entities that are managed as child entities. However, there is one centralised element: the root of trust at the top of the hierarchy should be a trusted entity in the ecosystem that is the one bootstraping the system. Typically it should be a regulatory body or a public administration. The approach for a single blockchain network is described in the following figure. The Trust Framework in the blockchain The Trust Framework in a given blockchain is not really a flat list, but a hierarchical structure, implemented as a Smart Contract: There is a special organisation which is at the root of the hierarchy. Ideally, this is a regulator, like the Central Bank of the country to manage banks, or the Ministry of Education to manage universities. This root entity is responsible for registering the identities of some trusted entities. For example, in a country with several regions with autonomous competencies to manage universities, the Ministry of Education could register in the blockchain the identities of the regional institutions which are responsible for managing the universities in each of their regions. Once this is done, each of the regional institutions can register the identities of dependent entities, like universities. The hierarchy can have several levels. For example, a university can be big and have several organisational units with some autonomy, maybe distributed geographically. It can create sub-identities and register them as child nodes in the blockchain. Some observations about this structure: An organisation can be registered in the blockchain only because its parent entity has registered it. No other entity in the Trust Framework can have performed the registration, not even the parent of the parent entity. An organisation is responsible for all its child entities, represented as child nodes in the blockchain. A third party external to the framework Creating identities A new identity can only be registered as a sub-node by an existing entity already registered in the system. The API used is /api/did/v1/identifiers and its definition is the following: GET /api/did/v1/identifiers Create an Identity anchored in the blockchain. Request parameters The body of the request is a JSON object with the following fields Name Type Description Example DID string The DID to resolve into a DID Document \"did:elsi:VATES-B60645900\" domain_name string Domain name to assign in the hierarchy \"in2.ala\" website string Website of the entity \"www.in2.es\" commercial_name string Commercial name \"IN2 Innovating 2gether\" new_privatekey PrivatekeyJWK The private key of the new entity parent_privatekey PrivatekeyJWK The private key of caller (in this case the owner of \"ala\") Example request : { \"DID\" : \"did:elsi:VATES-B60645900\" , \"domain_name\" : \"in2.ala\" , \"website\" : \"www.in2.es\" , \"commercial_name\" : \"IN2 Innovating 2gether\" , \"new_privatekey\" : { \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"d\" : \"Dqv3jmu8VNMKXWrHkppr5473sLMzWBczRhzdSdpxDfI\" , \"x\" : \"FTiW0a4r7S2SwjL7AlFlN1yJNWF--4_x3XTTxkFbJ9o\" , \"y\" : \"MmpxbQCOZ0L9U6rLLkD_U8LRGwYEHcoN-DPnEdlpt6A\" }, \"parent_privatekey\" : { \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"d\" : \"Dqv3jmu8VNMKXWrHkppr5473sLMzWBczRhzdSdpxDfI\" , \"x\" : \"NKW_0Fs4iumEegzKoOH0Trwtje1sXsG9Z1949sA8Omo\" , \"y\" : \"g4B3EI0qIdlcXTn-2RpUxgVX-sxNFdqCQDD0aHztVkk\" } } Reply Name Type Description payload json The DID document associated to the input DID A more detailed explanation of each field in the request follows: DID is the DID of the new entity. We support ELSI DID method (ELSI_DID_Method) and AlastriaID. The DID has to be created before the call to the API with the appropriate method for the DID. In the case of ELSI this is trivial and described in the section mentioned above. domain_name the domain name for the new entity in the Trust Framework. In the example it is in2.ala because it will be a sub-node of the Alastria one. The new identity will be created as a child node of the existing node owned by the entity controlling the parent_privatekey . If the parent domain name specified here is not owned by the entity controlling the parent_privatekey , an error is returned and no action is taken. website the website address in the off-chain world, so other participants can look more information about the entity. This field is informational only. However, it can be used by external appications to check that the entity in th ereal world corresponds to the one registered in th eblockchain. commercial_name the name of the company as it appears in the official register of the country/region. For example, in the case of IN2 (a Spanish business), the name should be the one registered in the Business Registry of Spain . new_privatekey is the Private Key of the new entity, in JWK format. In this case the new entity is IN2. Please make sure the server being called is highly trusted. parent_privatekey is the Private Key of the entity owning/controlling the parent node in the domain name, in JWK format. In this case the parent node is ala , corresponding to Alastria. Please make sure the server being called is highly trusted. Ideally, the server has to be operated by the same entity calling the API.","title":"Overview"},{"location":"trustframework/tf-overview/#trust-framework","text":"","title":"Trust Framework"},{"location":"trustframework/tf-overview/#introduction","text":"The trust framework is basically composed of two things: A list of the identities of trusted organisations stored in the blockchain, together with associated information for each entity. A process to add, modify and delete the trusted entities. The trust framework is designed to be largely decentralised and represents the trust relationships in the real world. The identities of the juridical persons involved in the ecosystem are registered in a common directory implemented in the blockchain following a hierarchical scheme very similar to the DNS (Domain Name Service) schema in the Internet. Once an entity is registered in the system, it is completely autonomous for adding other entities that are managed as child entities. However, there is one centralised element: the root of trust at the top of the hierarchy should be a trusted entity in the ecosystem that is the one bootstraping the system. Typically it should be a regulatory body or a public administration. The approach for a single blockchain network is described in the following figure. The Trust Framework in the blockchain The Trust Framework in a given blockchain is not really a flat list, but a hierarchical structure, implemented as a Smart Contract: There is a special organisation which is at the root of the hierarchy. Ideally, this is a regulator, like the Central Bank of the country to manage banks, or the Ministry of Education to manage universities. This root entity is responsible for registering the identities of some trusted entities. For example, in a country with several regions with autonomous competencies to manage universities, the Ministry of Education could register in the blockchain the identities of the regional institutions which are responsible for managing the universities in each of their regions. Once this is done, each of the regional institutions can register the identities of dependent entities, like universities. The hierarchy can have several levels. For example, a university can be big and have several organisational units with some autonomy, maybe distributed geographically. It can create sub-identities and register them as child nodes in the blockchain. Some observations about this structure: An organisation can be registered in the blockchain only because its parent entity has registered it. No other entity in the Trust Framework can have performed the registration, not even the parent of the parent entity. An organisation is responsible for all its child entities, represented as child nodes in the blockchain. A third party external to the framework","title":"Introduction"},{"location":"trustframework/tf-overview/#creating-identities","text":"A new identity can only be registered as a sub-node by an existing entity already registered in the system. The API used is /api/did/v1/identifiers and its definition is the following: GET /api/did/v1/identifiers Create an Identity anchored in the blockchain. Request parameters The body of the request is a JSON object with the following fields Name Type Description Example DID string The DID to resolve into a DID Document \"did:elsi:VATES-B60645900\" domain_name string Domain name to assign in the hierarchy \"in2.ala\" website string Website of the entity \"www.in2.es\" commercial_name string Commercial name \"IN2 Innovating 2gether\" new_privatekey PrivatekeyJWK The private key of the new entity parent_privatekey PrivatekeyJWK The private key of caller (in this case the owner of \"ala\") Example request : { \"DID\" : \"did:elsi:VATES-B60645900\" , \"domain_name\" : \"in2.ala\" , \"website\" : \"www.in2.es\" , \"commercial_name\" : \"IN2 Innovating 2gether\" , \"new_privatekey\" : { \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"d\" : \"Dqv3jmu8VNMKXWrHkppr5473sLMzWBczRhzdSdpxDfI\" , \"x\" : \"FTiW0a4r7S2SwjL7AlFlN1yJNWF--4_x3XTTxkFbJ9o\" , \"y\" : \"MmpxbQCOZ0L9U6rLLkD_U8LRGwYEHcoN-DPnEdlpt6A\" }, \"parent_privatekey\" : { \"kty\" : \"EC\" , \"crv\" : \"secp256k1\" , \"d\" : \"Dqv3jmu8VNMKXWrHkppr5473sLMzWBczRhzdSdpxDfI\" , \"x\" : \"NKW_0Fs4iumEegzKoOH0Trwtje1sXsG9Z1949sA8Omo\" , \"y\" : \"g4B3EI0qIdlcXTn-2RpUxgVX-sxNFdqCQDD0aHztVkk\" } } Reply Name Type Description payload json The DID document associated to the input DID A more detailed explanation of each field in the request follows: DID is the DID of the new entity. We support ELSI DID method (ELSI_DID_Method) and AlastriaID. The DID has to be created before the call to the API with the appropriate method for the DID. In the case of ELSI this is trivial and described in the section mentioned above. domain_name the domain name for the new entity in the Trust Framework. In the example it is in2.ala because it will be a sub-node of the Alastria one. The new identity will be created as a child node of the existing node owned by the entity controlling the parent_privatekey . If the parent domain name specified here is not owned by the entity controlling the parent_privatekey , an error is returned and no action is taken. website the website address in the off-chain world, so other participants can look more information about the entity. This field is informational only. However, it can be used by external appications to check that the entity in th ereal world corresponds to the one registered in th eblockchain. commercial_name the name of the company as it appears in the official register of the country/region. For example, in the case of IN2 (a Spanish business), the name should be the one registered in the Business Registry of Spain . new_privatekey is the Private Key of the new entity, in JWK format. In this case the new entity is IN2. Please make sure the server being called is highly trusted. parent_privatekey is the Private Key of the entity owning/controlling the parent node in the domain name, in JWK format. In this case the parent node is ala , corresponding to Alastria. Please make sure the server being called is highly trusted. Ideally, the server has to be operated by the same entity calling the API.","title":"Creating identities"}]}